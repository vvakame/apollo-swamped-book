= 小ネタ集

章にもならないような小ネタを適当に書いていきます。
これを本と言っていいのか若干悩みますが僕が本と言ったら本なんだ。

=== QueryとfetchMoreの謎

クライアント側をやり始めてまず困ったのがQueryとfetchMoreの対応関係です。
無限読み込みできるリストを作ろう！ということで取り組んだのですが、fetchMoreの使い方が全然わかりません。
結論からいうと、fetchMoreに対して幻想を抱きすぎていました。
溺死するレベルで。
自分のGraphQLエンドポイントはRelay Cursor Connections Specification@<fn>{relay-connections}を踏襲しているし、@<code>{@connection}って自動継ぎ足しが可能なやつ…？と思ったんですがそんなことは全然なかった。

//footnote[relay-connections][@<href>{https://facebook.github.io/relay/graphql/connections.htm}]

実際に必要なのは次の2ステップです。

 1. 自分で継ぎ足し分を取得するQueryを書く
 2. 自分で取得した結果を既存の結果と合成する

fetchMoreは自動継ぎ足し（データの結合）はしてくれません！
とりあえずここだけ覚えて帰ってください。
fetchMoreはQueryと大きな差はなく、updateQueryで元のデータと継ぎ足し用データを合成して返すステップがあるだけです。

ということを理解するまでにめっちゃ時間がかかった…。
公式のPaginationの説明@<fn>{apollo-pagenation}には必要なことが（ちゃんと）書いてあって、ここでやっていることを丸コピすればだいたいOKです。
魔法はない、ないんだ…！

//footnote[apollo-pagenation][@<href>{https://www.apollographql.com/docs/react/features/pagination.html}]

筆者の脳内に（のみ）存在していた魔法は次のような感じです。

1つ目。
継ぎ足し分を取得するQueryは自動生成される。
Apolloは魔法たっぷり！だから自動でやってくれるかな？と思ったけどそんなことはなかった。
Query中のPaginationが行われている箇所はRelay Cursor Connections Specificationにしたがっていれば検出可能でしょう。
複数候補がある場合でも、pathないし何らかの方法で該当箇所を明示可能です。
そうしたら、継ぎ足し分のQueryを生成するために元のDocument中の不要な箇所は自動的に削除できるはずだし、Pagingする方法は一意だし、自動で継ぎ足しクエリを生成可能だ！
ここまで妄想が捗ると、脳内では整合性が取れているので@<code>{@connection}はそのための仕様か！？とか思ってしまうわけである。
思い込みってこわい。
英語もちゃんと読め。

2つ目。
得られたデータを自分で合成する必要はない。
これについてもRelay Cursor Connections Specificationにしたがっていれば自動的に合成可能なはずである。
でもまぁそんなことはなかった。
先入観抜きにサンプルコードを見ると普通に合成している。
思い込みってこわい。

その他、悩ましい点。
画面内の構成にPageとComponentという区分が存在するとして、可能な限りQueryの実行はPage単位で行いたいわけです。
Componentが個別にバラバラとQueryを投げまくっていたらGraphQLのメリットが薄れてしまいますからね。
そうすると、各ComponentはFragmentを持ち、それをPageで合成し1つのQueryにすることになります。
この場合、fetchMoreの実装コードはQueryのそばに置くか、Fragmentのそばに置くか、どっちがいいでしょうか？
筆者は今の所、fetchMoreの関数を該当Componentまで引き回すのが面倒なので、Page側にfetchMoreの呼び出しやデータの合成までやってしまっています。
このあたりの意見は今後やりこみを続けていくと変わりそうな気もしています。

=== 日本におけるGraphQLコミュニティ（の不在）

これは適切な場所に筆者にリーチできていないだけの可能性も感じていますが…。

たとえば、Google Cloud Platformについて話したければ、GCPUG@<fn>{gcpug}のイベントやSlackに行けばいくらでも相談できたりします。
GraphQLってそういうのってあるんですかねぇ…？
アクティブな人@<fn>{fuckin-shy}がいるコミュニティが…！
そしてできればまずはインターネット上に…！

//footnote[gcpug][@<href>{https://gcpug.jp/} Google Cloud Platform User Group]
//footnote[fuckin-shy][できれば僕と知り合いの人（クソ人見知り野郎並の感想）]

あまり見当たらないので、会社のSlackの中でワイワイしたりgfx先生に絡んだりしています。
なんか適当にイベントやりたい…でも資料作りたくないし準備したくないのでアンカンファレンスとかがいい…。
#@# OK gfx: GrahQL Tokyo はアンカンファレンスですよ！（一度だけ行ったことある; ただ具体的な問題について議論するにはあまりむかない気がした; せっかく思い出したので graphql-tokyo.slack.com に入ってみた）
#@# vv: GraphQL Tokyoのイベント参加したことなかったのと、Slackがビタイチ動いてないので言及するのがためらわれる…！

=== react-apolloでApolloConsumerを使う

react-apolloでコードを書く時、ついつい@<code>{<Qiery />}やら@<code>{<Mutation />}やらを使いすぎてしまいます。
標準でお勧めされている使い方なので当然です。
しかし、1つのComponentの中で複数回Mutationを叩きたい場合、ネストが深くなるしエラーハンドリングの統合もめんどくさいです。
代わりに@<code>{<ApolloConsumer />}でclientを得て、mutationを直接叩く方法もあります。

というのに気がつくのに3時間くらいかかった。
もっと早く気がつくべき…。

=== FragmentがFragmentを使う場合にいい感じに@clientが消してくれない

QueryがFragmentを利用し、そのFragmentがさらにFragmentを参照することがあります。
多少ネストが深くなる構成の画面だったら余裕でそうなることがあるでしょう。
さて、@<code>{@client}なフィールドに対して、このネストしたFragmentを使った場合、apolloはいい感じにこれを消すことができません。
結果、サーバへのQueryの中に不要なFragmentが紛れ込んでしまい、仕様にしたがってサーバ側でエラーにされてしまう…ということが起こります。
これを回避するため、Fragmentを手で展開してネストしないようにする…などの工夫が必要です。

この問題に対して、パッチを送るか、せめてIssueを立てるべきなのですがまだやってませんすみません…。
#@# @client 使ってないので全然しらなかった！こわい！

=== Apolloがコードにドキュメントを書かない

Apolloプロジェクトはコードにドキュメントコメントを書いている場合が少ないです。
ですので、基本的にはWebのドキュメントが正…ということになるのですが、あまり網羅的な解説ではないです。
ドキュメントコメントをちゃんとメンテして、そこからWebサイト生成してくれないかなぁ…。
という愚痴。
独立したdocsディレクトリじゃなくて！

=== エラーハンドリングどうするの問題

GraphQLでサーバから返されたBad Request相当のエラーをどうハンドリングするかです。
フロントエンドでエラーをどのようにハンドリングして表示するか、真面目に考えるのも大変ですし、実装するのも大変です。
入力値のバリデーションにひっかかった場合、どうやってどのフィールドがエラーになったと明示するのか？
考えるのがめちゃめちゃめんどくさいですね…。
よい設計をご存知の人がいたらぜひ教えてください。

現状の方針として、React+Contextを利用してアプリ全体で単一のエラー集積所を用意、エラー自体はSnackbar（Toast）で表示するようにしました。
React力がまだ低いので、この実装にはちょいちょい問題点があります。

#@# TODO この辺にサンプルコード

たとえばURLからIDを切り出し、@<code>{@client}なMutationでIDを保存、Queryで詳細を取ってくる、という実装があるとします。
このとき、切り出したIDがなんらかの理由で存在しない場合、サーバ側からエラーが返ってきます@<fn>{404-error-from-server}。
すると、Context経由でトップレベルのComponentにstateの変更が発生し、全体にrerenderingが走ります。
結果、もう一度エラーが発生するようなQueryが実行されるため、エラー発生の無限ループに陥ります。

//footnote[404-error-from-server][この場合nullが返すのが正しい可能性もある。正しいのはどっちだ…！？こういう時のガイドラインみたいなのなくない？ないよね？]

これを解決する方法として、再描画された時にエラーにならないよう、1回目のエラーハンドリングで / にリダイレクトしておく、などの対応を取りました。
個人的にはこの挙動があまり好きではないので、該当のComponentに渡されるPropsが同一の場合、再描画しないようにする対応を取りたかったのですが上手にできませんでした…。
React.memoを使えばいけるのでは！？と思ったのですがまだまだReact力が足りていないようです。

GraphQLエラーハンドリングデザパタ集みたいなのがあると大変うれしいですね…。
@<href>{https://hnpwa.com/}とかに参考になるものがないかと思ったのですが、意外にGraphQLで実装されたものが存在しないようです。

#@# tomo : https://github.com/apollographql/apollo-link/tree/master/packages/apollo-link-error ミドルウェアでGenericなエラーをハンドリングしてView側に渡す手もありますねー

=== 雑に大きなデータをstateに突っ込んだら辛かった

Reactでかなり大きなデータをstateに突っ込み、ユーザに編集させていました。
しかし、stateに入れて表示しているデータはApolloの自動更新の恩恵を受けられません。
最終的に、ユーザが編集する可能性のある要素のみstateで持ち、それ以外のデータはstateを経由しないようにしました。
そうすると、ユーザが行った送信etcの操作に連動して画面の表示内容が自動的に更新できました。

明らかにReact力が低い人並の気づきですね…。
stateはstateであり変数じゃないんだ！ということを理解らされました。
一回も更新していないstateのプロパティをwarningとして表示してくれる仕組みほしいな…。
